#' Generate offspring for a general-population (genPop) parent with time-based setting and hospital thinning
#'
#' Simulates secondary infections (offspring) generated by a **general-population** parent.
#' The number of candidate offspring is drawn from a Negative Binomial distribution.
#' Candidate infection times are drawn from a **truncated Gamma** generation-time distribution
#' on \eqn{[0, t_\mathrm{outcome}]}. Each event is assigned a setting by comparing the infection
#' time to the parent’s hospitalisation time: events before admission are labelled
#' \code{"community"} and those after admission \code{"hospital"}. A hospital “quarantine”
#' effect then thins post-admission events with keep-probability \eqn{1 - \mathrm{hospital\_quarantine\_efficacy}}.
#' Finally, each offspring is assigned a class (\code{"HCW"} or \code{"genPop"}) using
#' setting-specific probabilities.
#'
#' @param parent_hospitalised Logical scalar. Whether the parent (infector) is hospitalised.
#' @param parent_time_to_hospitalisation Numeric scalar \eqn{\ge 0} or \code{NA}. If hospitalised,
#'   the time from infection to hospital admission; must be non-negative. If not hospitalised,
#'   must be \code{NA}.
#' @param parent_time_to_outcome Numeric scalar \eqn{\ge 0}. Time from infection to outcome
#'   (recovery/death); used to truncate the generation-time distribution.
#'
#' @param mn_offspring_genPop Positive numeric. Mean of the Negative Binomial offspring distribution
#'   for genPop parents (\code{rnbinom(mu = ..., size = ...)}).
#' @param overdisp_offspring_genPop Positive numeric. Negative Binomial \code{size} (overdispersion)
#'   for genPop parents.
#'
#' @param Tg_shape_genPop Positive numeric. Shape of the Gamma generation-time distribution
#'   for genPop parents (before truncation).
#' @param Tg_rate_genPop Positive numeric. Rate of the Gamma generation-time distribution
#'   for genPop parents (before truncation). Mean GT is \code{Tg_shape_genPop / Tg_rate_genPop}.
#'
#' @param hospital_quarantine_efficacy Numeric in \code{[0,1]}. Efficacy of hospital admission
#'   at reducing post-admission transmission; hospital keep-probability equals
#'   \code{1 - hospital_quarantine_efficacy}.
#'
#' @param prob_hcw_cond_genPop_comm Numeric in \code{[0,1]}. Probability that a **community**-located
#'   offspring generated by a genPop parent is an HCW.
#' @param prob_hcw_cond_genPop_hospital Numeric in \code{[0,1]}. Probability that a **hospital**-located
#'   offspring generated by a genPop parent is an HCW.
#' @export
offspring_function_genPop <- function(

  ## Characteristics and properties of the parent (who we are generating the offspring for)
  parent_info,

  ## Parameters of the offspring and generation time distributions for general population (genPop)
  mn_offspring_genPop = NULL,               # mean of the offspring distribution for general population
  overdisp_offspring_genPop = NULL,         # overdispersion of the offspring distribution for general population
  Tg_shape_genPop = NULL,                   # gamma shape parameter for Tg distribution for general population
  Tg_rate_genPop = NULL,                    # gamma rate parameter for Tg distribution for general population
  hospital_quarantine_efficacy = NULL,      # efficacy of hospitalisation at reducing transmission (quarantine)

  ## Probabilities for genPop infecting either genPop or HCWs, depending on the setting
  prob_hcw_cond_genPop_comm = NULL,         # prob that a community-located infection generated by genPop is a HCW
  prob_hcw_cond_genPop_hospital = NULL,      # prob that a hospital-located infection generated by genPop is a HCW
  hcw_available = NULL
) {

  # Step 0: Extract relevant parent information from parent_info
  parent_hospitalised = parent_info$hospitalisation                          # whether the parent (infector) is hospitalised or not
  parent_time_to_hospitalisation = parent_info$time_hospitalisation_relative # if parent is hospitalised, the time of hospitalisation (relative to infection)
  parent_time_to_outcome = parent_info$time_outcome_relative                 # the time when the parent dies/recovers (relative to time of infection)

  #########################################################################################
  ## Checks to make sure function inputs are correctly specified
  #########################################################################################
  if (is.null(parent_hospitalised) || length(parent_hospitalised) != 1L || !is.logical(parent_hospitalised) || is.na(parent_hospitalised)) {
    stop("`parent_hospitalised` must be a single logical value: TRUE or FALSE.", call. = FALSE)
  }
  if (isTRUE(parent_hospitalised)) {
    if (is.null(parent_time_to_hospitalisation) || length(parent_time_to_hospitalisation) != 1L ||
        !is.numeric(parent_time_to_hospitalisation) || is.na(parent_time_to_hospitalisation) || parent_time_to_hospitalisation < 0) {
      stop("When `parent_hospitalised` is TRUE, `parent_time_to_hospitalisation` must be a single non-negative numeric value (not NA).", call. = FALSE)
    }
  }
  if (is.null(parent_time_to_outcome) || length(parent_time_to_outcome) != 1L ||
      !is.numeric(parent_time_to_outcome) || is.na(parent_time_to_outcome) || parent_time_to_outcome < 0) {
    stop("`parent_time_to_outcome` must be a single non-negative numeric value (not NA).", call. = FALSE)
  }
  if (identical(parent_hospitalised, FALSE)) {
    if (!is.na(parent_time_to_hospitalisation)) {
      stop("When `parent_hospitalised` is FALSE, `parent_time_to_hospitalisation` must be NA.", call. = FALSE)
    }
  }
  if (is.null(hcw_available) || length(hcw_available) != 1L ||
      !is.numeric(hcw_available) || is.na(hcw_available) || hcw_available < 0) {
    stop("`hcw_available` must be a single non-negative numeric value.", call. = FALSE)
  }

  ########################################################################################################
  ## Generating offspring, offspring infection times, offspring infection locations & offspring classes
  ########################################################################################################

  # Step 1: Draw from offspring distribution to produce raw number of offspring
  num_offspring_raw <- rnbinom(n = 1, mu = mn_offspring_genPop, size = overdisp_offspring_genPop)

  # Step 2: Generate time of infection for each offspring based on the generation time
  infection_times <- rtrunc_gamma(n = num_offspring_raw, lower = 0, upper = parent_time_to_outcome, Tg_shape = Tg_shape_genPop, Tg_rate = Tg_rate_genPop)

  # Step 3: Generate location of infection depending on i) whether parent is hospitalised and ii) if hospitalised, the time
  #         of hospitalisation relative to time of infection
  t_hosp <- if (isTRUE(parent_hospitalised)) parent_time_to_hospitalisation else Inf
  if (is.finite(t_hosp) && parent_time_to_outcome <= t_hosp) t_hosp <- Inf
  infection_settings <- ifelse(infection_times < t_hosp, "community", "hospital")

  # Step 4: Thin / remove some hospital infections due to quarantining effect / similar
  p_keep_infection <- ifelse(infection_settings == "community", 1, 1 - hospital_quarantine_efficacy)
  keep_infection <- as.logical(rbinom(n = length(infection_times), size = 1, prob = p_keep_infection))
  infection_times <- infection_times[keep_infection]
  infection_settings <- infection_settings[keep_infection]
  num_offspring_quarantine <- sum(keep_infection)

  # Step 5: Assign class (HCW or genPop) to each offspring based on i) identity of parent and ii) location of infection
  offspring_class <- rep("genPop", length(infection_times))
  prob_hcw <- ifelse(infection_settings == "community", prob_hcw_cond_genPop_comm, prob_hcw_cond_genPop_hospital)
  flip_hcw <- as.logical(rbinom(n = length(infection_times), size = 1, prob = prob_hcw))
  offspring_class[flip_hcw] <- "HCW"

  # Step 6: Cap HCW infections based on hcw_available - if more HCWs were generated than available, randomly convert excess back to genPop
  hcw_idx <- which(offspring_class == "HCW")
  n_hcw_generated <- length(hcw_idx)
  if (n_hcw_generated > hcw_available) {
    # Randomly select which HCWs to convert back to genPop
    n_excess <- n_hcw_generated - hcw_available
    convert_idx <- sample(hcw_idx, size = n_excess)
    offspring_class[convert_idx] <- "genPop"
  }

  # Step 7: Define and output dataframe with the results
  offspring_df <- data.frame(infection_location = infection_settings,
                             time_infection_relative = infection_times,
                             class = offspring_class,
                             stringsAsFactors = FALSE)
  return(offspring_df)
}

